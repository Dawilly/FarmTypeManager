using System;
using System.Collections.Generic;
using System.Xml.Serialization;

using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Netcode;

using StardewValley;
using StardewValley.Audio;
using StardewValley.Tools;

using StardewModdingAPI;

using SObject = StardewValley.Object;

namespace FarmTypeManager;

public partial class ModEntry : Mod
{
    /// <summary>
    /// A breakable container with customized item contents.
    /// </summary>
    /// <remarks>
    /// This class is not currently designed to be saved by the game's native processes. All instances should be removed from the game before saving (i.e. end of day).
    /// Except where commented, this code copies or imitates SDV 1.4.3's BreakableContainer class.
    /// </remarks>
    public class BreakableContainerFTM : SObject
    {
        private const string BREAKSOUND = "barrelBreak";
        private const string HITSOUND = "woodWhack";
        private const int BARREL = 118;
        private const int CRATE = 119;

        [XmlElement("debris")]
        private readonly NetInt debris = new NetInt();

        [XmlElement("breakDebrisSource")]
        private readonly NetRectangle breakDebrisSource = new NetRectangle();

        [XmlElement("breakDebrisSource2")]
        private readonly NetRectangle breakDebrisSource2 = new NetRectangle();

        private new int shakeTimer;

        protected readonly Color color = new Color(130, 80, 30);

        /// <summary>The list of items dropped by this container when it breaks.</summary>
        /// <remarks>Replaces the predetermined objects generated by the original class.</remarks>
        [XmlElement("Items")]
        public readonly NetObjectList<Item> Items = new NetObjectList<Item>();

        /// <summary>The number of times this container needs to be hit before breaking.</summary>
        /// <remarks>Renames the original class's "health" field to avoid confusion with StardewValley.Object.health.</remarks>
        [XmlElement("HitsToBreak")]
        public readonly NetInt HitsToBreak = new NetInt();

        public BreakableContainerFTM()
        {
        }

        /// <summary>Create a new breakable container with the specified item contents.</summary>
        /// <param name="tile">The tile location of the container.</param>
        /// <param name="items">A set of items the container will drop when broken. Null or empty lists are valid.</param>
        /// <param name="isBarrel">If true, the container will use the "barrel" sprite. If false, it will use the "crate" sprite.</param>
        public BreakableContainerFTM(Vector2 tile, IEnumerable<Item> items, bool isBarrel = true) : base(tile, BreakableContainerFTM.BARREL, false)
        {
            this.Items.AddRange(items);

            // Uses a parameter instead of a 50% chance
            if (!isBarrel)
            {
                this.ParentSheetIndex = BreakableContainerFTM.CRATE;
            }

            this.HitsToBreak.Value = 3;
            this.debris.Value = 12;
            this.breakDebrisSource.Value = new Rectangle(598, 1275, 13, 4);
            this.breakDebrisSource2.Value = new Rectangle(611, 1275, 10, 4);
        }

        public override bool performToolAction(Tool t, GameLocation location)
        {
            if (t == null || !t.isHeavyHitter())
            {
                return false;
            }

            // Reflect to access SDV's multiplayer field
            Multiplayer multiplayer = Utility.Helper.Reflection.GetField<Multiplayer>(typeof(Game1), "multiplayer").GetValue();

            --this.HitsToBreak.Value;

            if (t is MeleeWeapon weapon && weapon.type.Value == 2)
            {
                --this.HitsToBreak.Value;
            }

            if (this.HitsToBreak.Value <= 0)
            {
                // This no longer checks whether "breakSound" is assigned
                location.playSound(BreakableContainerFTM.BREAKSOUND, null, null, SoundContext.Default);

                // This now passes the provided location, rather than the tool owner and their location
                this.releaseContents(location);
                t.getLastFarmerToUse().currentLocation.objects.Remove(this.TileLocation);

                int num = Game1.random.Next(4, 12);
                for (int index = 0; index < num; ++index)
                {
                    var temporarySprite = this.CreateTemporaryAnimatedSprite();

                    multiplayer.broadcastSprites(t.getLastFarmerToUse().currentLocation, temporarySprite);
                }
            }
            else
            {
                // This no longer checks whether "HITSOUND" is assigned
                this.shakeTimer = 300;
                location.playSound(BreakableContainerFTM.HITSOUND, null, null, SoundContext.Default);

                // This now reads the container's parent sheet index instead of "containerType"
                Game1.createRadialDebris(t.getLastFarmerToUse().currentLocation, 12, (int)this.TileLocation.X, (int)this.TileLocation.Y, Game1.random.Next(4, 7), false, -1, false); /*ParentSheetIndex == 120 ? 10000 : -1);*/
            }

            return false;
        }

        public override bool onExplosion(Farmer who, GameLocation location)
        {
            // Reflect to access SDV's multiplayer field
            Multiplayer multiplayer = Utility.Helper.Reflection.GetField<Multiplayer>(typeof(Game1), "multiplayer").GetValue();

            // This no longer passes the farmer
            this.releaseContents(location);

            int num = Game1.random.Next(4, 12);
            for (int index = 0; index < num; ++index)
            {
                var temporarySprite = this.CreateTemporaryAnimatedSprite();

                multiplayer.broadcastSprites(location, temporarySprite);
            }
            return true;
        }

        /// <summary>Drops the items from this container's "items" list.</summary>
        /// <param name="location">The location of the container.</param>
        /// <remarks>This replaces the method's original behavior and no longer takes Farmer as an argument.</remarks>
        public void releaseContents(GameLocation location)
        {
            // If there are no items listed, do nothing
            if (Items == null || Items.Count < 1) { return; }

            // Get the pixel-based location where these items should spawn
            var itemPosition = new Vector2(this.boundingBox.Center.X, this.boundingBox.Center.Y);

            // For each item in this container's item list
            foreach (Item item in this.Items)
            {
                // Spawn the item as "debris" at this location
                Game1.createItemDebris(item, itemPosition, Utility.RNG.Next(4), location); 
            }
        }

        public override void updateWhenCurrentLocation(GameTime time, GameLocation environment)
        {
            if (this.shakeTimer <= 0)
            {
                return;
            }

            this.shakeTimer -= time.ElapsedGameTime.Milliseconds;
        }

        public override void draw(SpriteBatch spriteBatch, int x, int y, float alpha = 1f)
        {
            Vector2 vector2 = this.getScale() * 4f;
            Vector2 local = Game1.GlobalToLocal(Game1.viewport, new Vector2((float)(x * 64), (float)(y * 64 - 64)));
            Rectangle destinationRectangle = new Rectangle((int)((double)local.X - (double)vector2.X / 2.0), (int)((double)local.Y - (double)vector2.Y / 2.0), (int)(64.0 + (double)vector2.X), (int)(128.0 + (double)vector2.Y / 2.0));
            if (this.shakeTimer > 0)
            {
                int num = this.shakeTimer / 100 + 1;
                destinationRectangle.X += Game1.random.Next(-num, num + 1);
                destinationRectangle.Y += Game1.random.Next(-num, num + 1);
            }

            int index = this.showNextIndex.Value ? this.ParentSheetIndex + 1 : this.ParentSheetIndex;
            float layerDepth = Math.Max(0.0f, ((y + 1) * 64 - 1) / 10000f) + (this.ParentSheetIndex == 105 ? 0.0015f : 0.0f);

            spriteBatch.Draw(Game1.bigCraftableSpriteSheet, destinationRectangle, SObject.getSourceRectForBigCraftable(index), Color.White * alpha, 0.0f, Vector2.Zero, SpriteEffects.None, layerDepth);
        }

        protected override void initNetFields()
        {
            base.initNetFields();

            // Use this class's modified set of net fields
            this.NetFields.AddField(this.Items);
            this.NetFields.AddField(this.HitsToBreak);
            this.NetFields.AddField(this.debris);
            this.NetFields.AddField(this.breakDebrisSource);
            this.NetFields.AddField(this.breakDebrisSource2);
        }

        private TemporaryAnimatedSprite CreateTemporaryAnimatedSprite()
        {
            var source = Game1.random.NextDouble() < 0.5 ? this.breakDebrisSource.Value : this.breakDebrisSource2.Value;
            var position = this.TileLocation * 64f + new Vector2(32f, 32f);
            bool flipped = Game1.random.NextDouble() < 0.5;
            float layerDepth = (float)((this.TileLocation.Y * 64.0 + 32.0) / 10000.0);
            float rotation = (float)(Game1.random.Next(-5, 6) * 3.14159274101257 / 8.0);
            float rotationChange = (float)(Game1.random.Next(-5, 6) * 3.14159274101257 / 64.0);

            var temporarySprite = new TemporaryAnimatedSprite("LooseSprites\\Cursors", source, 999f, 1, 0, position, false, flipped, layerDepth, 0.01f, this.color, 4f, 0.0f, rotation, rotationChange)
            {
                motion = new Vector2(Game1.random.Next(-30, 31) / 10f, Game1.random.Next(-10, -7)),
                acceleration = new Vector2(0.0f, 0.3f)
            };

            return temporarySprite;
        }
    }
}
